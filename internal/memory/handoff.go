package memory

import (
	"crypto/rand"
	"encoding/hex"
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"time"

	"github.com/sgx-labs/statelessagent/internal/config"
)

// HandoffResult holds the result of writing a handoff note.
type HandoffResult struct {
	Path      string `json:"path"`
	SessionID string `json:"session_id"`
	Machine   string `json:"machine"`
	Written   string `json:"written"`
}

// GenerateHandoffNote generates markdown content for a handoff note.
func GenerateHandoffNote(
	accomplishments []string,
	decisions []string,
	currentState string,
	nextSession string,
	filesChanged []string,
	sessionID string,
	machine string,
) string {
	now := time.Now()
	timestamp := now.UTC().Format(time.RFC3339)
	if machine == "" {
		machine = getMachineName()
	}
	if sessionID == "" {
		sessionID = generateSessionID()
	}

	accomplishmentsMD := "- (none recorded)"
	if len(accomplishments) > 0 {
		lines := make([]string, len(accomplishments))
		for i, a := range accomplishments {
			lines[i] = "- " + a
		}
		accomplishmentsMD = strings.Join(lines, "\n")
	}

	decisionsMD := "- (none recorded)"
	if len(decisions) > 0 {
		lines := make([]string, len(decisions))
		for i, d := range decisions {
			lines[i] = "- " + d
		}
		decisionsMD = strings.Join(lines, "\n")
	}

	filesMD := "- (none)"
	if len(filesChanged) > 0 {
		lines := make([]string, len(filesChanged))
		for i, f := range filesChanged {
			lines[i] = "- `" + f + "`"
		}
		filesMD = strings.Join(lines, "\n")
	}

	if currentState == "" {
		currentState = "(not recorded)"
	}
	if nextSession == "" {
		nextSession = "(no specific next steps noted)"
	}

	return fmt.Sprintf(`---
title: Session Handoff %s
content_type: handoff
session_id: %s
machine: %s
created: %s
tags:
  - handoff
  - auto-generated
---

# Session Handoff

## Accomplishments
%s

## Decisions Made
%s

## Current State
%s

## Next Session
%s

## Files Changed
%s

---
*Auto-generated by SAME (Stateless Agent Memory Engine)*
`, now.Format("2006-01-02 15:04"), sessionID, machine, timestamp,
		accomplishmentsMD, decisionsMD, currentState, nextSession, filesMD)
}

// WriteHandoff generates and writes a handoff note to the vault.
func WriteHandoff(
	accomplishments []string,
	decisions []string,
	currentState string,
	nextSession string,
	filesChanged []string,
	sessionID string,
) *HandoffResult {
	if sessionID == "" {
		sessionID = generateSessionID()
	}
	machine := getMachineName()

	content := GenerateHandoffNote(
		accomplishments, decisions, currentState, nextSession,
		filesChanged, sessionID, machine,
	)

	filename := time.Now().Format("2006-01-02-150405") + "-handoff.md"
	relativePath := config.HandoffDirectory() + "/" + filename

	// SECURITY: Validate the resolved path stays inside the vault boundary.
	absPath, ok := config.SafeVaultSubpath(relativePath)
	if !ok {
		fmt.Fprintf(os.Stderr, "same: handoff path is outside your notes folder â€” skipping\n")
		return nil
	}
	dir := filepath.Dir(absPath)
	os.MkdirAll(dir, 0o755)

	if err := os.WriteFile(absPath, []byte(content), 0o644); err != nil {
		return nil
	}

	return &HandoffResult{
		Path:      relativePath,
		SessionID: sessionID,
		Machine:   machine,
		Written:   absPath,
	}
}

// AutoHandoffFromTranscript generates a handoff note from a transcript file.
func AutoHandoffFromTranscript(transcriptPath string, sessionID string) *HandoffResult {
	inputs := GetSessionSummaryInputs(transcriptPath)

	msgCount, _ := inputs["message_count"].(int)
	if msgCount < 3 {
		return nil
	}

	userMsgs, _ := inputs["user_messages"].([]string)
	toolCalls, _ := inputs["tool_calls"].([]ToolCall)
	filesChanged, _ := inputs["files_changed"].([]string)

	var accomplishments []string
	if len(userMsgs) > 0 {
		limit := 5
		if len(userMsgs) < limit {
			limit = len(userMsgs)
		}
		for _, msg := range userMsgs[:limit] {
			summary := msg
			if len(summary) > 100 {
				summary = summary[:100]
			}
			summary = strings.TrimSpace(summary)
			if summary != "" {
				accomplishments = append(accomplishments, "Worked on: "+summary)
			}
		}
	}
	if len(accomplishments) == 0 {
		accomplishments = []string{"(auto-extracted from transcript)"}
	}

	currentState := fmt.Sprintf("Session had %d messages, %d tool calls", msgCount, len(toolCalls))

	return WriteHandoff(
		accomplishments,
		[]string{"(see decision extractor for detailed extraction)"},
		currentState,
		"(review handoff and add specific next steps)",
		filesChanged,
		sessionID,
	)
}

func generateSessionID() string {
	ts := time.Now().Format("20060102-150405")
	b := make([]byte, 4)
	rand.Read(b)
	return ts + "-" + hex.EncodeToString(b)
}

func getMachineName() string {
	name, _ := os.Hostname()
	return name
}
